## 1.2 함수

### 1.2.1 함수란 무엇인가?

함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싼 실행 단위
리액트의 컴포넌트도 일반 함수처럼 props 객체를 매개변수로 받고, return 문으로 JSX를 반환한다. 함수형 컴포넌트는 JSX 형태로 호출한다.

### 1.2.2 함수를 정의하는 4가지 방법

> 프로젝트 상황에 맞게 일관된 함수 작성법을 사용하는 것이 중요하다.

1. 함수 선언문

   ```js
   function add(a, b) {
     return a + b;
   }
   ```

   - function 키워드를 사용하여 함수를 선언하는 방법이다.
   - 함수 선언문은 선언 위치에 상관없이 호출할 수 있다. 이를 호이스팅이라고 한다. 그래서 함수가 코드의 어느 위치에 있든 호출할 수 있지만, 스코프가 길어지면 관리하기 어려워질 수 있다.

2. 함수 표현식

   ```js
   const sum = function (a, b) {
     return a + b;
   };
   ```

   - 함수 표현식은 함수를 변수에 할당하는 방식이다.
   - const sum처럼 함수 이름을 생략할 수 있다. 자바스크립트에서 함수는 일급 객체이므로 매개변수, 반환값, 변수에 할당할 때 사용할 수 있다.
   - 함수 표현식은 함수 선언문과 달리 호이스팅되지 않아서, 정의하기 전에 호출하면 에러가 발생한다.

3. Function 생성자

   ```js
   const add = new Function("a", "b", "return a + b");
   ```

   - 이 방법은 잘 사용하지 않고 권장되지 않는다.

4. 화살표 함수

   ```js
   const add = (a, b) => {
     return a + b;
   };

   // 더 간략한 형태로도 작성 가능하다.
   const add = (a, b) => a + b;
   ```

   - ES6에서 새로 추가된 함수 작성 방법이다.
   - 화살표 함수는 몇 가지 특징이 있다:
     - 생성자 함수로 사용할 수 없다. 그래서 new 키워드를 써서 객체를 만들 수 없다.
     - arguments 객체가 존재하지 않는다. 대신 rest 연산자를 사용할 수 있다.
     - this 바인딩이 없어서 상위 스코프의 this를 따른다. 이로 인해 클래스의 메서드에서 화살표 함수를 사용할 때, 클래스 인스턴스의 this를 올바르게 참조할 수 있다.

#### 함수 선언문과 함수 표현식의 차이

- 호이스팅 여부 <br/>
  - 함수 선언문: 함수 호이스팅이 발생한다. 함수 실행 전에 메모리에 등록되므로 선언 이전에 호출이 가능하다.
  - 함수 표현식: 변수 호이스팅이 발생하지만, 변수는 undefined로 초기화되므로 정의하기 전에 호출하면 TypeError가 발생한다.

### 1.2.3 다양한 함수 살펴보기

#### 1. 즉시 실행 함수(Immediately Invoked Function Expression, IIFE)

: 즉시 실행 함수는 함수를 정의하자마자 즉시 실행하는 방식이다. 이렇게 하면 전역 스코프를 오염시키지 않고 독립적인 함수 스코프를 생성할 수 있다.

```js
(function (a, b) {
  return a + b;
})(10, 14);

((a, b) => a + b)(10, 14);
```

-> IIFE는 재사용할 필요가 없는 코드 블록에 유용하다. 주로 초기화 코드나 한 번만 실행해야 하는 로직을 처리할 때 사용된다.

#### 2. 고차 함수(Higher Order Function)

: 고차 함수는 함수를 인수로 받거나, 함수를 반환하는 함수를 말한다. 이를 통해 코드의 재사용성을 높일 수 있다.

```js
const doubledArray = [1, 2, 3].map((item) => item * 2); // 함수 인수로 사용
console.log(doubledArray); // [2, 4, 6]

const add = (a) => (b) => a + b; // 함수를 반환
console.log(add(1)(3)); // 4
```

-> 이러한 고차 함수 패턴은 함수형 프로그래밍에서 자주 사용되며, 리액트의 map, filter와 같은 배열 메서드에서 활용된다.

[HOC 패턴을 사용한 좋은 사례](https://blog.hwahae.co.kr/all/tech/11631)

### 1.2.4. 함수를 만들 때 주의 사항

- 함수의 부수 효과를 최대한 억제하기.

  - 순수 함수: 부수 효과가 없는 함수. 동일한 인수를 받으면 동일한 결과를 반환하여 예측 가능하며 안정적이다.

  - 웹 애플리케이션을 만드는 과정에서 외부에 영향을 미치는 부수 효과는 피할 수 없지만, 최소화하도록 함수를 작성해야 한다.

  - 리액트 관점에서는 useEffect의 작동을 최소화하여 컴포넌트의 안정성을 높이도록 해야 한다.

  - 결론적으로, 함수에서 가능한 부수 효과를 최소화하고, 함수의 실행과 결과를 최대한 예측 가능하도록 설계해야 한다. 이는 유지보수에 도움이 된다.

- 가능한 한 함수를 작게 만들어라.

  - 하나의 함수에서 너무 많은 일을 하지 마라.

  - ESLint의 max-line-per-function 규칙은 50줄이 넘어가면 과도하게 큰 함수로 분류한다.

- 누구나 이해할 수 있는 이름을 붙여라.

  - 가능한 한 함수 이름은 간결하고 이해하기 쉽게 붙이는 것이 좋다.

  - useEffect나 useCallback 등의 훅에 넘겨주는 콜백 함수에 이름을 붙여주면 가독성에 도움이 된다.

    ```js
    useEffect(function apiRequest() {
      // do something..
    }, []);
    ```
