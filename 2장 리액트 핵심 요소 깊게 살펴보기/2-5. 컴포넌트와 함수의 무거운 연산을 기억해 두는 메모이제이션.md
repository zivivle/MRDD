## 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

리액트에서 제공하는 API 중 useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

### 메모이제이션 기법은 언제 사용하면 좋을까?

### 2-5-1. 주장1: 섣부른 최적화(premature optimization)는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

- 메모이제이션은 비용이 든다.
  - 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 비용
  - 이전에 결과물을 메모리에 저장해 두었다가 다시 꺼내오는 비용
- 따라서 대부분의 가벼운 작업은 매번 작업을 수행해 결과를 반환하는 것이 빠를 수 있다
- 일단 애플리케이션을 어느 정도 만든 이후 개발자 도구나 useEffect를 활용해 렌더링이 일어나는 지점을 확인하고 필요한 곳에서만 최적화해야 한다.

### 2.5.2 주장2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자

- 잘못된 memo로 지불해야 하는 비용은 props에 대한 얕은 비교이다.
- memo를 하지 않았을 때 발생할 수 있는 문제
  - 렌더링 및 컴포넌트 내부 복잡한 로직 재실행
  - 위의 내용을 반복적으로 실행하고, 이전과 현재 트리 비교
- 의존성 배열의 경우, 사용되는 함수의 반환값을 useMemo를로 감싼다면 값이 변경되지 않는 한 같은 참조를 유지해 사용하는 쪽에서 참조의 투명성 유지 가능

### 2.5.3 결론 및 정리

- 아직 리액트를 배우고 있거나 깊이 이해할 시간이 있다면 주장1과 같이 렌더링 여부를 확인하고 크롬 메모리 프로파일러로 분석하면서 이해도를 높이자.
- 현업에서 사용하는 경우, 로직이 들어간 컴포넌트를 메모이제이션하자.
- useCallback은 다른 컴포넌트의 props로 넘어가는 경우, useMemo는 props로 넘어가거나 활용할 여지가 있는 경우 사용하자.
