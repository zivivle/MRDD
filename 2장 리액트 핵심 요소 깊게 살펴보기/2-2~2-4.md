## 2-2 가상 DOM과 리액트 파이버

### 가상 DOM

사용자 인터랙션에 따른 모든 DOM의 변경보다는 결과물을 제공하는 것이 브라우저 뿐만 아니라 개발자에게도 유용하다. 가상 DOM은 리액트(react-dom)가 관리하는 가상의 DOM으로, 웹페이지가 표시해야 할 DOM을 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때, 실제 브라우저의 DOM에 반영한다.

### 리액트 파이버

#### 파이버 트리

두 개가 존재: 현재 모습을 담은 파이버 트리 & 작업 중인 상태의 workInProgress 트리

파이버 작업이 끝나면 포인터만 변경해 workInProgress 트리를 현태 트리로 바꿈 → 더블 버퍼링 작업
![alt text](image.png)

1. 업데이트가 발생
2. 새로운 데이터로 새로운 workInProgress 트리를 빌드
3. workInProgress가 마무리되면 다음 렌더링에 사용되고 UI에 최종적으로 반영되면 workInProgress가 current로 대체

## 2-3 클래스 컴포넌트와 함수 컴포넌트

### 2-3-1 클래스 컴포넌트

**extends 구문이 가능한 React.Component 및 React.PureComponent**

**생명주기 메서드**

| 이름                              | 설명                                                                                                       |
| --------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| render()                          | 순수해야 하며 내부에서 this.setState 호출 불가                                                             |
| comcomponentDidMount()            | 마운트 후 호출되는 함수. 상태 변경 시, UI 업데이트 하기 전에 실행되어 변경확인 X                           |
| componentDidUpdate()              | 업데이트 후 실행                                                                                           |
| componentWillUnmount()            | 언마운트 될 때 호출. 클린업 함수 호출 최적의 위치. setState 호출 불가능                                    |
| shouldComponentUpdate()           | 변경점으로 다시 리렌더링을 방지하고자 할 때 사용. 조건을 사용하여 업데이트 여부 결정                       |
| static getDericedStateFromProps() | render() 호출하기 직전에 호출                                                                              |
| getSnapShoteBeforeUpdate()        | DOM 업데이트 이전에 호출. 반환값은 componentDidUpdate로 전달                                               |
| getDerivedStateFromError()        | 에러상황 시 호출. 자식 컴포넌트에서 에러 발생 시 호출되는 에러 메서드                                      |
| componentDidCatch()               | 자식 컴포넌트에서 에러가 발생 시 호출. getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행 |

**클래스 컴포넌트의 한계**

- 테이트 흐름 추적 어려움: state의 흐름 추적이 어려움
- 내부 로직 재사용 어려움: 재사용 필요 시, HOC 사용
- 기능이 많아질 수록 컴포넌트 크기 증가
- 클래스 문법의 적응: 프로토타입 및 함수보다 늦게 나옴
- 코드 최적화 어려움: 번들 크키 줄이는데 어려움

### 2-3-2 함수 컴포넌트

**클래스와 차이점**
함수 컴포넌트와 렌더링된 값: 함수는 호출 시점 및 상황(props 및 state 기준)을 기억하고 있지만, 클래스는 중간에 변경이 되더라도 변경된 값을 읽을 수 있기에 피치 못할 상황 야기

## 2-4 렌더링은 어떻게 일어나는가?

### 2-4-1 리액트의 렌더링

**리액트의 렌더링**: props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM결과를 브라우저에 제공할 것인지 계산하는 일련의 과정

**리렌더링 발생 시점** <br/>
리액트에서는 특정 상황에서 렌더링이 발생한다. 렌더링은 아래와 같은 경우에 발생

최초 렌더링

- 컴포넌트가 처음으로 화면에 표시될 때.

리렌더링

- 클래스 컴포넌트
  - setState() 함수가 실행될 때.
  - forceUpdate() 함수가 실행될 때.
- 함수 컴포넌트
  - setState() 함수가 실행될 때.
  - useReducer의 dispatch 함수가 실행될 때.
  - 컴포넌트의 key props가 변경될 때.
  - 부모 컴포넌트가 렌더링될 때 → 자식 컴포넌트도 자동으로 렌더링.

### 2-4-3 리액트의 렌더링 프로세스

리액트의 렌더링 과정은 두 단계로 나뉜다.

**Render Phase (렌더 단계)** <br/>
컴포넌트를 렌더링하고 변경 사항을 계산하는 단계.<br/>
컴포넌트의 type, props, key를 비교하여 변경된 것이 있는지 확인.<br/>
변경이 필요하다면 해당 컴포넌트에 대한 렌더링 작업이 체크됨.
<br/><br/>
**Commit Phase (커밋 단계)** <br/>
변경 사항을 실제 DOM에 적용하는 과정.<br/>
이 단계가 완료되어야 브라우저에서 화면이 업데이트됨.<br/>
주의: 렌더링이 발생했다고 해서 반드시 DOM이 업데이트되는 것은 아님. 변경 사항이 없다고 판단되면 DOM 업데이트는 생략됨.
